/*
 *  SPDX-License-Identifier: MIT
 */

#include "faest_defines.h"

#include <stddef.h>
#include <stdint.h>

#ifndef FAEST_@PARAM@_H
#define FAEST_@PARAM@_H

#ifdef __cplusplus
extern "C" {
#endif

#define FAEST_@PARAM@_PUBLIC_KEY_SIZE @PK_SIZE@
#define FAEST_@PARAM@_PRIVATE_KEY_SIZE @SK_SIZE@
#define FAEST_@PARAM@_MAX_SIGNATURE_SIZE @SIG_SIZE@

/* Signature API */

// 

// TODO - Add paramset struct faest_param_t here, containing faest_L1, faest_L3, faest_L5.... ?
typedef enum faest_paramid_t {
    PARAMETER_SET_INVALID = 0,
    FAEST_L1_S = 1,
    FAEST_L1_F = 2,
    FAEST_L3_S = 3,
    FAEST_L3_F = 4,
    FAEST_L5_S = 5,
    FAEST_L5_F = 6,
    PARAMETER_SET_MAX_INDEX = 7
} faest_paramid_t;

// Param for the cipher that is used,, AES in this case
typedef struct cipher_param_t {
    uint32_t keySize;
    uint32_t blockSize;
    uint32_t numRounds;
    uint32_t numSboxes;
    uint32_t stateSizeBits;
    uint32_t stateSizeBytes;
    uint32_t stateSizeWords;
} cipher_param_t;

typedef struct faest_param_t {
    uint32_t lambda;                // lambda
    uint32_t lenExpAESWitnessBits;  // l
    uint32_t t;                     // t, number of VOLE instances (number of repetition)
    uint32_t k0;                    // k0 = ceil(lambda/t)
    uint32_t k1;                    // k1 = floor(lambda/t)
    uint32_t t0;                    // t0 = lambda mod t; number if BOLE instances of size 2^(k0)
    uint32_t t1;                    // t1 = t - (lambda mod t); number if BOLE instances of size 2^(k1)
    uint32_t pkSizeBytes;
    uint32_t skSizeBytes;
    uint32_t numOpenRounds;         // TODO: unsure what this would be in the vole case ?
    uint32_t seedSizeBytes;
    uint32_t saltSizeBytes;
    uint32_t digestSizeBytes;
} faest_param_t;

// TODO - Add paramset struct paramset_t here, containing numround, numsbox, seedSizeBytes, digestSizeBytes.... ?
typedef struct faest_paramset_t {
    cipher_param_t cipher_param;
    faest_param_t faest_param;
    faest_paramid_t faest_paramid;
} faest_paramset_t;


/**
 * Key generation function.
 * Generates a public and private key pair, for the specified parameter set.
 *
 * @param[out] pk         The new public key.
 * @param[out] sk         The new private key.
 *
 * @return Returns 0 for success, or a nonzero value indicating an error.
 */
FAEST_EXPORT int FAEST_CALLING_CONVENTION faest_@PARAM_L@_keygen(const uint8_t* pk, const uint8_t* sk);

/**
 * Signature function.
 * Signs a message with the given keypair.
 *
 * @param[in] sk      The signer's private key.
 * @param[in] message The message to be signed.
 * @param[in] message_len The length of the message, in bytes.
 * @param[out] signature A buffer to hold the signature. The specific max number of
 * bytes required for a parameter set is given by @PARAM_L@_signature_size(). Note
 * that the length of each signature varies slightly, for the parameter sets
 * using the FS transform.  The parameter sets using the Unruh transform have a
 * fixed length.
 * @param[in,out] signature_len The length of the provided signature buffer.
 * On success, this is set to the number of bytes written to the signature buffer.
 *
 * @return Returns 0 for success, or a nonzero value indicating an error.
 *
 * @see faest_verify(), faest_keygen(), faest_signature_size()
 */
FAEST_EXPORT int FAEST_CALLING_CONVENTION faest_@PARAM_L@_sign(const uint8_t* sk, const uint8_t* message, size_t message_len, uint8_t* signature, size_t* signature_len);

/**
 * Verification function.
 * Verifies a signature is valid with respect to a public key and message.
 *
 * @param[in] pk      The signer's public key.
 * @param[in] message The message the signature purpotedly signs.
 * @param[in] message_len The length of the message, in bytes.
 * @param[in] signature The signature to verify.
 * @param[in] signature_len The length of the signature.
 *
 * @return Returns 0 for success, indicating a valid signature, or a nonzero
 * value indicating an error or an invalid signature.
 *
 * @see faest_sign(), faest_keygen()
 */
FAEST_EXPORT int FAEST_CALLING_CONVENTION faest_@PARAM_L@_verify(const uint8_t* pk, const uint8_t* message, size_t message_len, const uint8_t* signature, size_t signature_len);

/**
 * Check that a key pair is valid.
 *
 * @param[in] sk The private key to check
 * @param[in] pk The public key to check
 *
 * @return Returns 0 if the key pair is valid, or a nonzero value indicating an error
 */
FAEST_EXPORT int FAEST_CALLING_CONVENTION faest_@PARAM_L@_validate_keypair(const uint8_t* sk, const uint8_t* pk);

/**
 * Clear data of a private key.
 *
 * @param[out] key The private key to clear
 */
FAEST_EXPORT void FAEST_CALLING_CONVENTION faest_@PARAM_L@_clear_private_key(uint8_t* key);

/**
 * Compute public key from private key.
 *
 * @param[in] sk The private key
 * @param[out] pk The public key to be populated
 * @return Returns 0 on success, or a nonzero value indicating an error.
 **/
FAEST_EXPORT int FAEST_CALLING_CONVENTION faest_@PARAM_L@_sk_to_pk(const uint8_t* sk, uint8_t* pk);

#ifdef __cplusplus
}
#endif

#endif

// vim: ft=c
