/*
 *  SPDX-License-Identifier: MIT
 */

#ifdef SUPERCOP
#include "crypto_sign.h"
#else
#include "api.h"
#endif

#include "faest_@PARAM_L@.h"
#include "owf.h"

#include <string.h>

// memory layout of the public key: OWF input || OWF output
#define PK_INPUT(pk) (pk)
#define PK_OUTPUT(pk) (&pk[@PK_SIZE@ / 2])

// memory layout of the secret key: OWF input || OWF key
#define SK_INPUT(sk) (sk)
#define SK_KEY(sk) (&sk[@PK_SIZE@ / 2])

int crypto_sign_keypair(unsigned char* pk, unsigned char* sk) {
  int ret = faest_@PARAM_L@_keygen(pk, SK_KEY(sk));
  if (ret == 0) {
    memcpy(SK_INPUT(sk), PK_INPUT(pk), @PK_SIZE@ / 2);
  }
  return ret;
}

int crypto_sign(unsigned char* sm, unsigned long long* smlen, const unsigned char* m,
                unsigned long long mlen, const unsigned char* sk) {
  uint8_t pk[@PK_SIZE@];
  memcpy(PK_INPUT(pk), SK_INPUT(sk), @PK_SIZE@ / 2);
  if (!faest_@PARAM_L@_owf(SK_KEY(sk), PK_INPUT(pk), PK_OUTPUT(pk))) {
    // invalid key
    return -1;
  }

  *smlen = mlen + FAEST_@PARAM@_SIGNATURE_SIZE;
  memmove(sm, m, mlen);

  return faest_@PARAM_L@_sign(SK_KEY(sk), pk, sm, mlen, sm + mlen, NULL);
}

int crypto_sign_open(unsigned char* m, unsigned long long* mlen, const unsigned char* sm,
                     unsigned long long smlen, const unsigned char* pk) {
  if (smlen < FAEST_@PARAM@_SIGNATURE_SIZE) {
    // signature too short
    return -1;
  }
  unsigned long long m_length = smlen - FAEST_@PARAM@_SIGNATURE_SIZE;
  if (!faest_@PARAM_L@_verify(pk, sm, m_length, sm + m_length, FAEST_@PARAM@_SIGNATURE_SIZE)) {
    return -1;
  }

  *mlen = m_length;
  memmove(m, sm, m_length);
  return 0;
}

// vim: ft=c
